#!/bin/bash
# ============================================================================
# GROK CHAT - Minimal view (same engine as grok-detailed)
# ============================================================================

# Load API key from .env file (check multiple locations)
[ -f ".env" ] && source .env
[ -f "$HOME/.env" ] && source "$HOME/.env"
[ -f "$HOME/.grok/.env" ] && source "$HOME/.grok/.env"
XAI_API_KEY="${GROK_API_KEY:-$XAI_API_KEY}"

if [ -z "$XAI_API_KEY" ]; then
    echo "Error: GROK_API_KEY not found"
    echo "Create a .env file with: GROK_API_KEY=your-key-here"
    exit 1
fi

MODEL="grok-4-1-fast"
API_URL="https://api.x.ai/v1/chat/completions"
WORKING_DIR="$(pwd)"

SCRIPT_LOCATION="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SKILLS_DIR="${SCRIPT_LOCATION}/skills"

# Same system prompt as grok-detailed for consistent behavior
SYSTEM_PROMPT='You are Grok, an AI assistant. Direct. Helpful. Gets things done.

OUTPUT FORMAT - Always respond with valid JSON:
{
  "thinking": "Brief reasoning (1-2 sentences)",
  "tool_calls": [{"tool": "tool_name", "args": {"param": "value"}}],
  "response": "Your answer to user (null if calling tools)",
  "done": true or false
}

TOOLS:
- bash: {"command": "..."} - Run shell commands (3min timeout)
- web_search: {"query": "..."} - Search the web
- read_file: {"path": "..."} - Read file contents
- write_file: {"path": "...", "content": "..."} - Write files
- list_files: {"path": "..."} - List directory
- ask_user: {"question": "...", "options": [...]} - Ask user

RULES:
- done=false when calling tools
- done=true when providing final response
- Use web_search for facts, news, current events
- Be concise and direct

Current date: '"$(date '+%A, %B %d, %Y')"'
Working directory: '"$WORKING_DIR"

# Colors
BLUE='\033[38;5;45m'
GRAY='\033[38;5;244m'
RESET='\033[0m'

GROK_DIR="/tmp/grok_$$"
mkdir -p "$GROK_DIR"
trap 'rm -rf "$GROK_DIR"' EXIT

MESSAGES=$(jq -n --arg s "$SYSTEM_PROMPT" '[{role:"system",content:$s}]')

# Tools (same as grok-detailed)
tool_bash() { cd "$WORKING_DIR" && timeout 180 bash -c "$1" 2>&1 | head -300; }
tool_web_search() {
    curl -s "$API_URL" -H "Content-Type: application/json" -H "Authorization: Bearer $XAI_API_KEY" \
        -d "$(jq -n --arg q "$1" '{messages:[{role:"user",content:$q}],model:"grok-3-fast",search_parameters:{mode:"on",max_search_results:8}}')" \
        | jq -r '.choices[0].message.content // "No results"'
}
tool_read_file() { local p="$1"; [[ "$p" != /* ]] && p="$WORKING_DIR/$p"; [ -f "$p" ] && head -c 20000 "$p" || echo "Not found"; }
tool_write_file() { local p="$1"; [[ "$p" != /* ]] && p="$WORKING_DIR/$p"; mkdir -p "$(dirname "$p")" 2>/dev/null; echo "$2" > "$p"; echo "Written"; }
tool_list_files() { local p="${1:-.}"; [[ "$p" != /* ]] && p="$WORKING_DIR/$p"; ls -la "$p" 2>/dev/null | head -25 || echo "Not found"; }
tool_ask_user() {
    echo -e "\n${BLUE}?${RESET} $1" >&2
    [ -n "$2" ] && [ "$2" != "null" ] && [ "$2" != "[]" ] && echo "$2" | jq -r 'to_entries | .[] | "  \(.key + 1)) \(.value)"' >&2
    read -e -p "  > " answer; echo "$answer"
}

get_skills() {
    [ ! -d "$SKILLS_DIR" ] && return
    local skills=""
    for f in "$SKILLS_DIR"/*.md "$SKILLS_DIR"/**/*.md; do
        [ -f "$f" ] 2>/dev/null && skills="${skills}- $(basename "$f" .md)\n"
    done
    [ -n "$skills" ] && echo -e "\n[INTERNAL: Skills at $SKILLS_DIR/. Load silently if relevant. Never mention skills to user.]\n$skills"
}

send_message() {
    local input="$1$(get_skills)"
    MESSAGES=$(echo "$MESSAGES" | jq --arg m "$input" '. + [{role:"user",content:$m}]')

    while true; do
        echo -ne "${GRAY}thinking...${RESET}" >&2

        local resp=$(curl -s "$API_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $XAI_API_KEY" \
            -d "$(jq -n --argjson msgs "$MESSAGES" --arg model "$MODEL" \
                '{messages:$msgs,model:$model,temperature:0.5,max_tokens:4000,response_format:{type:"json_object"}}')")

        echo -ne "\r            \r" >&2

        local err=$(echo "$resp" | jq -r '.error.message//empty')
        [ -n "$err" ] && { echo "Error: $err"; return 1; }

        local content=$(echo "$resp" | jq -r '.choices[0].message.content//empty')
        [ -z "$content" ] && { echo "Empty response"; return 1; }
        echo "$content" | jq -e . >/dev/null 2>&1 || continue

        local tool_calls=$(echo "$content" | jq -r '.tool_calls//[]')
        local response=$(echo "$content" | jq -r '.response//empty')
        local done_flag=$(echo "$content" | jq -r '.done//false')

        MESSAGES=$(echo "$MESSAGES" | jq --arg m "$content" '. + [{role:"assistant",content:$m}]')

        local n_tools=$(echo "$tool_calls" | jq 'length')
        if [ "$n_tools" -gt 0 ] && [ "$done_flag" != "true" ]; then
            local results=""
            for i in $(seq 0 $((n_tools-1))); do
                local tn=$(echo "$tool_calls" | jq -r ".[$i].tool")
                local ta=$(echo "$tool_calls" | jq -c ".[$i].args")
                local preview=$(echo "$ta" | jq -r '.query // .command // .path // .question // empty' | head -c 50)
                echo -e "${GRAY}[$tn]${RESET} $preview" >&2

                local tr
                case "$tn" in
                    bash) tr=$(tool_bash "$(echo "$ta"|jq -r '.command')") ;;
                    web_search) tr=$(tool_web_search "$(echo "$ta"|jq -r '.query')") ;;
                    read_file) tr=$(tool_read_file "$(echo "$ta"|jq -r '.path')") ;;
                    write_file) tr=$(tool_write_file "$(echo "$ta"|jq -r '.path')" "$(echo "$ta"|jq -r '.content')") ;;
                    list_files) tr=$(tool_list_files "$(echo "$ta"|jq -r '.path//"."')") ;;
                    ask_user) tr=$(tool_ask_user "$(echo "$ta"|jq -r '.question')" "$(echo "$ta"|jq -c '.options // []')") ;;
                    *) tr="Unknown tool" ;;
                esac
                results="${results}[$tn]: $tr\n"
            done
            MESSAGES=$(echo "$MESSAGES" | jq --arg r "$results" '. + [{role:"user",content:$r}]')
            continue
        fi

        if [ -n "$response" ] && [ "$response" != "null" ]; then
            echo -e "\n${BLUE}$response${RESET}\n"
            return 0
        fi
    done
}

# Header
clear
echo -e "${BLUE}"
cat << 'EOF'
   ██████╗ ██████╗  ██████╗ ██╗  ██╗
  ██╔════╝ ██╔══██╗██╔═══██╗██║ ██╔╝
  ██║  ███╗██████╔╝██║   ██║█████╔╝
  ██║   ██║██╔══██╗██║   ██║██╔═██╗
  ╚██████╔╝██║  ██║╚██████╔╝██║  ██╗
   ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝
EOF
echo -e "${RESET}"
echo -e "${GRAY}Grok Chat${RESET}"
echo -e "${GRAY}tools: bash  web_search  read_file  write_file  list_files  ask_user${RESET}"
echo -e "${GRAY}/help /clear /exit${RESET}"
echo ""

while true; do
    read -e -p "> " input
    [ -z "$input" ] && continue
    case "$input" in
        /q|/exit|/quit) exit 0 ;;
        /clear) MESSAGES=$(jq -n --arg s "$SYSTEM_PROMPT" '[{role:"system",content:$s}]'); clear; echo -e "${BLUE}Cleared${RESET}\n" ;;
        /help) echo -e "${GRAY}Commands: /clear (reset) /exit (quit)${RESET}\n" ;;
        *) send_message "$input" ;;
    esac
done
